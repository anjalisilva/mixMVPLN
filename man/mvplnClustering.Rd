% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvplnCode.R
\name{mvplnClustering}
\alias{mvplnClustering}
\title{Model-Based Clustering Using mixtures of MVPLN}
\usage{
mvplnClustering(
  dataset,
  membership = "none",
  gmin,
  gmax,
  nChains = 3,
  nIterations = NA,
  initMethod = "kmeans",
  nInitIterations = 2,
  normalize = "Yes",
  numNodes = NA
)
}
\arguments{
\item{dataset}{A list of length nUnits, containing Y_j matrices.
A matrix Y_j has size r x p, and the dataset will have 'j' such
matrices with j = 1,...,n. If a Y_j has all zeros, such Y_j will
be removed prior to cluster analysis.}

\item{membership}{A numeric vector of size length(dataset) containing the
cluster membership of each Y_j matrix. If not available, leave as
"none".}

\item{gmin}{A positive integer specifying the minimum number of components
to be considered in the clustering run.}

\item{gmax}{A positive integer, >gmin, specifying the maximum number of
components to be considered in the clustering run.}

\item{nChains}{A positive integer specifying the number of Markov chains.
Default is 3, the recommended minimum number.}

\item{nIterations}{A positive integer specifying the number of iterations
for each MCMC chain (including warmup). The value should be greater than
40. The upper limit will depend on size of dataset.}

\item{initMethod}{An algorithm for initialization. Current options are
"kmeans", "random", "medoids", "clara", or "fanny". Default is "kmeans".}

\item{nInitIterations}{A positive integer or zero, specifying the number
of initialization runs to be considered. Default is 0.}

\item{normalize}{A string with options "Yes" or "No" specifying
if normalization should be performed. Currently, normalization factors
are calculated using TMM method of edgeR package. Default is "Yes".}

\item{numNodes}{A positive integer indicating the number of nodes to be
used from the local machine to run the clustering algorithm. Else
leave as NA, so default will be detected as
parallel::makeCluster(parallel::detectCores() - 1).}
}
\value{
Returns an S3 object of class mvplnParallel with results.
\itemize{
  \item dataset - The input dataset on which clustering is performed.
  \item nUnits - Number of units in the input dataset.
  \item nVariables - Number of variables in the input dataset.
  \item nOccassions - Number of occassions in the input dataset.
  \item normFactors - A vector of normalization factors used for
     input dataset.
  \item gmin - Minimum number of components considered in the clustering
     run.
  \item gmax - Maximum number of components considered in the clustering
     run.
  \item initalizationMethod - Method used for initialization.
  \item allResults - A list with all results.
  \item loglikelihood - A vector with value of final log-likelihoods for
     each cluster size.
  \item nParameters - A vector with number of parameters for each
     cluster size.
  \item trueLabels - The vector of true labels, if provided by user.
  \item ICL_all - A list with all ICL model selection results.
  \item BIC_all - A list with all BIC model selection results.
  \item AIC_all - A list with all AIC model selection results.
  \item AIC3_all - A list with all AIC3 model selection results.
  \item totalTime - Total time used for clustering and model selection.
}
}
\description{
Performs clustering using mixtures of matrix variate Poisson-log normal
(MVPLN) distribution and model selection using AIC, AIC3,
BIC and ICL.
}
\examples{
# Not run
# Generating simulated matrix variate count data
# set.seed(1234)
# trueG <- 2 # number of total G
# truer <- 2 # number of total occasions
# truep <- 3 # number of total responses
# trueN <- 100 # number of total units

# Mu is a r x p matrix
# trueM1 <- matrix(rep(6, (truer * truep)),
#                   ncol = truep,
#                   nrow = truer, byrow = TRUE)

# trueM2 <- matrix(rep(1, (truer * truep)),
#                   ncol = truep,
#                   nrow = truer,
#                   byrow = TRUE)

# trueMall <- rbind(trueM1, trueM2)

# Phi is a r x r matrix
# Loading needed packages for generating data
# if (!require(clusterGeneration)) install.packages("clusterGeneration")
# Covariance matrix containing variances and covariances between r occasions
# truePhi1 <- clusterGeneration::genPositiveDefMat("unifcorrmat",
#                                                    dim = truer,
#                                                    rangeVar = c(1, 1.7))$Sigma
# truePhi1[1, 1] <- 1 # For identifiability issues

# truePhi2 <- clusterGeneration::genPositiveDefMat("unifcorrmat",
#                                                   dim = truer,
#                                                   rangeVar = c(0.7, 0.7))$Sigma
# truePhi2[1, 1] <- 1 # For identifiability issues

# truePhiall <- rbind(truePhi1, truePhi2)

# Omega is a p x p matrix
# Covariance matrix containing variances and covariances between p responses
# trueOmega1 <- clusterGeneration::genPositiveDefMat("unifcorrmat", dim = truep,
#                                   rangeVar = c(1, 1.7))$Sigma

# trueOmega2 <- clusterGeneration::genPositiveDefMat("unifcorrmat", dim = truep,
#                                   rangeVar = c(0.7, 0.7))$Sigma

# trueOmegaAll <- rbind(trueOmega1, trueOmega2)

# sampleData <- mixMVPLN::mvplnDataGenerator(nOccasions = truer,
#                                            nResponses = truep,
#                                            nUnits = trueN,
#                                            mixingProportions = c(0.79, 0.21),
#                                            matrixMean = trueMall,
#                                            phi = truePhiall,
#                                            omega = trueOmegaAll)

# Clustering simulated matrix variate count data
# clusteringResults <- mixMVPLN::mvplnClustering(dataset = sampleData$dataset,
#                                      membership = sampleData$truemembership,
#                                      gmin = 1,
#                                      gmax = 3,
#                                      nChains = 3,
#                                      nIterations = 300,
#                                      initMethod = "kmeans",
#                                      nInitIterations = 1,
#                                      normalize = "Yes")

}
\references{
Silva, A. et al. (2018). Finite Mixtures of Matrix Variate Poisson-Log Normal Distributions
for Three-Way Count Data. \href{https://arxiv.org/abs/1807.08380}{arXiv preprint arXiv:1807.08380}.
}
\author{
{Anjali Silva, \email{anjali.silva@uhnresearch.ca}, Sanjeena Dang,
         \email{sdang@math.binghamton.edu}. }
}
