% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvplnCode.R
\name{mvplnClustering}
\alias{mvplnClustering}
\title{Model-Based Clustering Using mixtures of MVPLN}
\usage{
mvplnClustering(
  dataset,
  membership = "none",
  gmin,
  gmax,
  nChains = 3,
  nIterations = NA,
  initMethod = "kmeans",
  nInitIterations = 2,
  normalize = "Yes",
  numNodes = NA
)
}
\arguments{
\item{dataset}{A list of length nUnits, containing Y_j matrices.
A matrix Y_j has size r x p, and the dataset will have 'j' such
matrices with j = 1,...,n. If a Y_j has all zeros, such Y_j will
be removed prior to cluster analysis.}

\item{membership}{A numeric vector of size length(dataset) containing the
cluster membership of each Y_j matrix. If not available, leave as
"none".}

\item{gmin}{A positive integer specifying the minimum number of components
to be considered in the clustering run.}

\item{gmax}{A positive integer, >gmin, specifying the maximum number of
components to be considered in the clustering run.}

\item{nChains}{A positive integer specifying the number of Markov chains.
Default is 3, the recommended minimum number.}

\item{nIterations}{A positive integer specifying the number of iterations
for each MCMC chain (including warmup). The value should be greater than
40. The upper limit will depend on size of dataset.}

\item{initMethod}{An algorithm for initialization. Current options are
"kmeans", "random", "medoids", "clara", or "fanny". Default is "kmeans".}

\item{nInitIterations}{A positive integer or zero, specifying the number
of initialization runs to be considered. Default is 0.}

\item{normalize}{A string with options "Yes" or "No" specifying
if normalization should be performed. Currently, normalization factors
are calculated using TMM method of edgeR package. Default is "Yes".}

\item{numNodes}{A positive integer indicating the number of nodes to be
used from the local machine to run the clustering algorithm. Else
leave as NA, so default will be detected as
parallel::makeCluster(parallel::detectCores() - 1).}
}
\value{
Returns an S3 object of class mvplnParallel with results.
\itemize{
  \item dataset - The input dataset on which clustering is performed.
  \item nUnits - Number of units in the input dataset.
  \item nVariables - Number of variables in the input dataset.
  \item nOccassions - Number of occassions in the input dataset.
  \item normFactors - A vector of normalization factors used for
     input dataset.
  \item gmin - Minimum number of components considered in the clustering
     run.
  \item gmax - Maximum number of components considered in the clustering
     run.
  \item initalizationMethod - Method used for initialization.
  \item allResults - A list with all results.
  \item loglikelihood - A vector with value of final log-likelihoods for
     each cluster size.
  \item nParameters - A vector with number of parameters for each
     cluster size.
  \item trueLabels - The vector of true labels, if provided by user.
  \item ICL_all - A list with all ICL model selection results.
  \item BIC_all - A list with all BIC model selection results.
  \item AIC_all - A list with all AIC model selection results.
  \item AIC3_all - A list with all AIC3 model selection results.
  \item totalTime - Total time used for clustering and model selection.
}
}
\description{
Performs clustering using mixtures of matrix variate Poisson-log normal
(MVPLN) distribution and model selection using AIC, AIC3,
BIC and ICL.
}
\examples{
# Generating simulated matrix variate count data
set.seed(1)
true_G <- 2 # number of total G
true_r <- 2 # number of total occasions
true_p <- 3 # number of total responses
true_n <- 100 # number of total units

# Mu is a r x p matrix
true_M1 <- matrix(rep(6, (true_r * true_p)),
                  ncol = true_p,
                  nrow = true_r, byrow = TRUE)

true_M2 <- matrix(rep(1, (true_r * true_p)),
                  ncol = true_p,
                  nrow = true_r,
                  byrow = TRUE)

true_M_all <- rbind(true_M1, true_M2)

# Phi is a r x r matrix
# Loading needed packages for generating data
if (!require(clusterGeneration)) install.packages("clusterGeneration")
# Covariance matrix containing variances and covariances between r occasions
true_Phi1 <- clusterGeneration::genPositiveDefMat("unifcorrmat",
                                                  dim = true_r,
                                                  rangeVar = c(1, 1.7))$Sigma
true_Phi1[1, 1] <- 1 # For identifiability issues

true_Phi2 <- clusterGeneration::genPositiveDefMat("unifcorrmat",
                                                  dim = true_r,
                                                  rangeVar = c(0.7, 0.7))$Sigma
true_Phi2[1, 1] <- 1 # For identifiability issues

true_Phi_all <- rbind(true_Phi1, true_Phi2)

# Omega is a p x p matrix
# Covariance matrix containing variances and covariances between p responses
true_Omega1 <- genPositiveDefMat("unifcorrmat", dim = true_p,
                                 rangeVar = c(1, 1.7))$Sigma

true_Omega2 <- genPositiveDefMat("unifcorrmat", dim = true_p,
                                 rangeVar = c(0.7, 0.7))$Sigma

true_Omega_all <- rbind(true_Omega1,true_Omega2)

sampleData <- mvplnDataGenerator(nOccasions = true_r,
                                 nResponses = true_p,
                                 nUnits = true_n,
                                 mixingProportions = c(0.79, 0.21),
                                 matrixMean = true_M_all,
                                 phi = true_Phi_all,
                                 omega = true_Omega_all)

# Clustering simulated matrix variate count data
clusteringResults <- mvplnClustering(dataset = sampleData$dataset,
                                     membership = sampleData$truemembership,
                                     gmin = 1,
                                     gmax = 3,
                                     nChains = 3,
                                     nIterations = 300,
                                     initMethod = "kmeans",
                                     nInitIterations = 1,
                                     normalize = "Yes")

}
\references{
Silva, A. et al. (2019). Finite Mixtures of Matrix Variate Poisson-Log Normal Distributions
for Three-Way Count Data. \href{https://arxiv.org/abs/1807.08380}{arXiv preprint arXiv:1807.08380}.
}
\author{
{Anjali Silva, \email{anjali.silva@uhnresearch.ca}, Sanjeena Dang,
         \email{sdang@math.binghamton.edu}. }
}
